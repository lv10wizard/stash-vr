# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

interface BaseFile {
    basename: String!
    created_at: Time!
    fingerprints: [Fingerprint!]!
    id: ID!
    mod_time: Time!
    parent_folder_id: ID!
    path: String!
    size: Int64!
    updated_at: Time!
    zip_file_id: ID
}

"Scraped Content is the forming union over the different scrapers"
union ScrapedContent = ScrapedGallery | ScrapedMovie | ScrapedPerformer | ScrapedScene | ScrapedStudio | ScrapedTag

union VisualFile = ImageFile | VideoFile

type AutoTagMetadataOptions {
    "IDs of performers to tag files with, or \"*\" for all"
    performers: [String!]
    "IDs of studios to tag files with, or \"*\" for all"
    studios: [String!]
    "IDs of tags to tag files with, or \"*\" for all"
    tags: [String!]
}

type ConfigDLNAResult {
    "True if DLNA service should be enabled by default"
    enabled: Boolean!
    "List of interfaces to run DLNA on. Empty for all"
    interfaces: [String!]!
    serverName: String!
    "Order to sort videos"
    videoSortOrder: String!
    "List of IPs whitelisted for DLNA service"
    whitelistedIPs: [String!]!
}

type ConfigDefaultSettingsResult {
    autoTag: AutoTagMetadataOptions
    "If true, delete file checkbox will be checked by default"
    deleteFile: Boolean
    "If true, delete generated supporting files checkbox will be checked by default"
    deleteGenerated: Boolean
    generate: GenerateMetadataOptions
    identify: IdentifyMetadataTaskOptions
    scan: ScanMetadataOptions
}

type ConfigDisableDropdownCreate {
    movie: Boolean!
    performer: Boolean!
    studio: Boolean!
    tag: Boolean!
}

type ConfigGeneralResult {
    "API Key"
    apiKey: String!
    "Path to backup directory"
    backupDirectoryPath: String!
    "Path to blobs - required for filesystem blob storage"
    blobsPath: String!
    "Where to store blobs"
    blobsStorage: BlobsStorageType!
    "Path to cache"
    cachePath: String!
    "Whether to calculate MD5 checksums for scene video files"
    calculateMD5: Boolean!
    "Path to the config file used"
    configFilePath: String!
    "True if galleries should be created from folders with images"
    createGalleriesFromFolders: Boolean!
    "Create Image Clips from Video extensions when Videos are disabled in Library"
    createImageClipsFromVideos: Boolean!
    "Custom Performer Image Location"
    customPerformerImageLocation: String
    "Path to the SQLite database"
    databasePath: String!
    "whether to include range in generated funscript heatmaps"
    drawFunscriptHeatmapRange: Boolean!
    "Array of file regexp to exclude from Video Scans"
    excludes: [String!]!
    "Regex used to identify images as gallery covers"
    galleryCoverRegex: String!
    "Array of gallery zip file extensions"
    galleryExtensions: [String!]!
    "Path to generated files"
    generatedPath: String!
    "Array of file regexp to exclude from Image Scans"
    imageExcludes: [String!]!
    "Array of image file extensions"
    imageExtensions: [String!]!
    """

    ffmpeg stream input args - injected before input file
    These are applied when live transcoding
    """
    liveTranscodeInputArgs: [String!]!
    """

    ffmpeg stream output args - injected before output file
    These are applied when live transcoding
    """
    liveTranscodeOutputArgs: [String!]!
    "Whether to log http access"
    logAccess: Boolean!
    "Name of the log file"
    logFile: String
    "Minimum log level"
    logLevel: String!
    "Whether to also output to stderr"
    logOut: Boolean!
    "Maximum session cookie age"
    maxSessionAge: Int!
    "Max streaming transcode size"
    maxStreamingTranscodeSize: StreamingResolutionEnum
    "Max generated transcode size"
    maxTranscodeSize: StreamingResolutionEnum
    "Path to import/export files"
    metadataPath: String!
    "Number of parallel tasks to start during scan/generate"
    parallelTasks: Int!
    "Password"
    password: String!
    "Include audio stream in previews"
    previewAudio: Boolean!
    "Duration of end of video to exclude when generating previews"
    previewExcludeEnd: String!
    "Duration of start of video to exclude when generating previews"
    previewExcludeStart: String!
    "Preset when generating preview"
    previewPreset: PreviewPreset!
    "Preview segment duration, in seconds"
    previewSegmentDuration: Float!
    "Number of segments in a preview file"
    previewSegments: Int!
    "Python path - resolved using path if unset"
    pythonPath: String!
    "Scraper CDP path. Path to chrome executable or remote address"
    scraperCDPPath: String @deprecated(reason: "use ConfigResult.scraping instead")
    "Whether the scraper should check for invalid certificates"
    scraperCertCheck: Boolean! @deprecated(reason: "use ConfigResult.scraping instead")
    "Scraper user agent string"
    scraperUserAgent: String @deprecated(reason: "use ConfigResult.scraping instead")
    "Path to scrapers"
    scrapersPath: String!
    "Stash-box instances used for tagging"
    stashBoxes: [StashBox!]!
    "Array of file paths to content"
    stashes: [StashConfig!]!
    "Transcode Hardware Acceleration"
    transcodeHardwareAcceleration: Boolean!
    """

    ffmpeg transcode input args - injected before input file
    These are applied to generated transcodes (previews and transcodes)
    """
    transcodeInputArgs: [String!]!
    """

    ffmpeg transcode output args - injected before output file
    These are applied to generated transcodes (previews and transcodes)
    """
    transcodeOutputArgs: [String!]!
    "Comma separated list of proxies to allow traffic from"
    trustedProxies: [String!] @deprecated(reason: "no longer supported")
    "Username"
    username: String!
    "Array of video file extensions"
    videoExtensions: [String!]!
    "Hash algorithm to use for generated file naming"
    videoFileNamingAlgorithm: HashAlgorithm!
    "Write image thumbnails to disk when generating on the fly"
    writeImageThumbnails: Boolean!
}

type ConfigImageLightboxResult {
    displayMode: ImageLightboxDisplayMode
    resetZoomOnNav: Boolean
    scaleUp: Boolean
    scrollAttemptsBeforeChange: Int!
    scrollMode: ImageLightboxScrollMode
    slideshowDelay: Int
}

type ConfigInterfaceResult {
    "If true, video will autostart on load in the scene player"
    autostartVideo: Boolean
    "If true, video will autostart when loading from play random or play selected"
    autostartVideoOnPlaySelected: Boolean
    "If true, next scene in playlist will be played at video end by default"
    continuePlaylistDefault: Boolean
    "Custom CSS"
    css: String
    cssEnabled: Boolean
    "Custom Locales"
    customLocales: String
    customLocalesEnabled: Boolean
    "Fields are true if creating via dropdown menus are disabled"
    disableDropdownCreate: ConfigDisableDropdownCreate!
    disabledDropdownCreate: ConfigDisableDropdownCreate! @deprecated(reason: "Use disableDropdownCreate")
    "Funscript Time Offset"
    funscriptOffset: Int
    "Handy Connection Key"
    handyKey: String
    imageLightbox: ConfigImageLightboxResult!
    "Custom Javascript"
    javascript: String
    javascriptEnabled: Boolean
    "Interface language"
    language: String
    "Maximum duration (in seconds) in which a scene video will loop in the scene player"
    maximumLoopDuration: Int
    "Ordered list of items that should be shown in the menu"
    menuItems: [String!]
    "True if we should not auto-open a browser window on startup"
    noBrowser: Boolean
    "True if we should send desktop notifications"
    notificationsEnabled: Boolean
    "Show scene scrubber by default"
    showScrubber: Boolean
    "If true, studio overlays will be shown as text instead of logo images"
    showStudioAsText: Boolean
    "Slideshow Delay"
    slideshowDelay: Int @deprecated(reason: "Use imageLightbox.slideshowDelay")
    "Enable sound on mouseover previews"
    soundOnPreview: Boolean
    "Whether to use Stash Hosted Funscript"
    useStashHostedFunscript: Boolean
    "Wall playback type"
    wallPlayback: String
    "Show title and tags in wall view"
    wallShowTitle: Boolean
}

"All configuration settings"
type ConfigResult {
    defaults: ConfigDefaultSettingsResult!
    dlna: ConfigDLNAResult!
    general: ConfigGeneralResult!
    interface: ConfigInterfaceResult!
    scraping: ConfigScrapingResult!
    ui: Map!
}

type ConfigScrapingResult {
    "Tags blacklist during scraping"
    excludeTagPatterns: [String!]!
    "Scraper CDP path. Path to chrome executable or remote address"
    scraperCDPPath: String
    "Whether the scraper should check for invalid certificates"
    scraperCertCheck: Boolean!
    "Scraper user agent string"
    scraperUserAgent: String
}

type DLNAIP {
    ipAddress: String!
    "Time until IP will be no longer allowed/disallowed"
    until: Time
}

type DLNAStatus {
    allowedIPAddresses: [DLNAIP!]!
    recentIPAddresses: [String!]!
    running: Boolean!
    "If not currently running, time until it will be started. If running, time until it will be stopped"
    until: Time
}

"Directory structure of a path"
type Directory {
    directories: [String!]!
    parent: String
    path: String!
}

type FindGalleriesResultType {
    count: Int!
    galleries: [Gallery!]!
}

type FindGalleryChaptersResultType {
    chapters: [GalleryChapter!]!
    count: Int!
}

type FindImagesResultType {
    count: Int!
    "Total file size in bytes"
    filesize: Float!
    images: [Image!]!
    "Total megapixels of the images"
    megapixels: Float!
}

type FindMoviesResultType {
    count: Int!
    movies: [Movie!]!
}

type FindPerformersResultType {
    count: Int!
    performers: [Performer!]!
}

type FindSceneMarkersResultType {
    count: Int!
    scene_markers: [SceneMarker!]!
}

type FindScenesResultType {
    count: Int!
    "Total duration in seconds"
    duration: Float!
    "Total file size in bytes"
    filesize: Float!
    scenes: [Scene!]!
}

type FindStudiosResultType {
    count: Int!
    studios: [Studio!]!
}

type FindTagsResultType {
    count: Int!
    tags: [Tag!]!
}

type Fingerprint {
    type: String!
    value: String!
}

type Folder {
    created_at: Time!
    id: ID!
    mod_time: Time!
    parent_folder_id: ID
    path: String!
    updated_at: Time!
    zip_file_id: ID
}

"Gallery type"
type Gallery {
    chapters: [GalleryChapter!]!
    checksum: String! @deprecated(reason: "Use files.fingerprints")
    cover: Image
    created_at: Time!
    date: String
    details: String
    file_mod_time: Time @deprecated(reason: "Use files.mod_time")
    files: [GalleryFile!]!
    folder: Folder
    id: ID!
    image_count: Int!
    "The images in the gallery"
    images: [Image!]! @deprecated(reason: "Use findImages")
    organized: Boolean!
    path: String @deprecated(reason: "Use files.path")
    performers: [Performer!]!
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    scenes: [Scene!]!
    studio: Studio
    tags: [Tag!]!
    title: String
    updated_at: Time!
    url: String @deprecated(reason: "Use urls")
    urls: [String!]!
}

type GalleryChapter {
    created_at: Time!
    gallery: Gallery!
    id: ID!
    image_index: Int!
    title: String!
    updated_at: Time!
}

type GalleryFile implements BaseFile {
    basename: String!
    created_at: Time!
    fingerprints: [Fingerprint!]!
    id: ID!
    mod_time: Time!
    parent_folder_id: ID!
    path: String!
    size: Int64!
    updated_at: Time!
    zip_file_id: ID
}

type GenerateMetadataOptions {
    clipPreviews: Boolean
    covers: Boolean
    imagePreviews: Boolean
    interactiveHeatmapsSpeeds: Boolean
    markerImagePreviews: Boolean
    markerScreenshots: Boolean
    markers: Boolean
    phashes: Boolean
    previewOptions: GeneratePreviewOptions
    previews: Boolean
    sprites: Boolean
    transcodes: Boolean
}

type GeneratePreviewOptions {
    "Duration of end of video to exclude when generating previews"
    previewExcludeEnd: String
    "Duration of start of video to exclude when generating previews"
    previewExcludeStart: String
    "Preset when generating preview"
    previewPreset: PreviewPreset
    "Preview segment duration, in seconds"
    previewSegmentDuration: Float
    "Number of segments in a preview file"
    previewSegments: Int
}

type IdentifyFieldOptions {
    "creates missing objects if needed - only applicable for performers, tags and studios"
    createMissing: Boolean
    field: String!
    strategy: IdentifyFieldStrategy!
}

type IdentifyMetadataOptions {
    "any fields missing from here are defaulted to MERGE and createMissing false"
    fieldOptions: [IdentifyFieldOptions!]
    "defaults to true if not provided"
    includeMalePerformers: Boolean
    "defaults to true if not provided"
    setCoverImage: Boolean
    setOrganized: Boolean
    "tag to tag skipped multiple matches with"
    skipMultipleMatchTag: String
    "defaults to true if not provided"
    skipMultipleMatches: Boolean
    "tag to tag skipped single name performers with"
    skipSingleNamePerformerTag: String
    "defaults to true if not provided"
    skipSingleNamePerformers: Boolean
}

type IdentifyMetadataTaskOptions {
    "Options defined here override the configured defaults"
    options: IdentifyMetadataOptions
    "An ordered list of sources to identify items with. Only the first source that finds a match is used."
    sources: [IdentifySource!]!
}

type IdentifySource {
    "Options defined for a source override the defaults"
    options: IdentifyMetadataOptions
    source: ScraperSource!
}

type Image {
    checksum: String @deprecated(reason: "Use files.fingerprints")
    created_at: Time!
    date: String
    file: ImageFileType! @deprecated(reason: "Use visual_files")
    file_mod_time: Time @deprecated(reason: "Use files.mod_time")
    files: [ImageFile!]! @deprecated(reason: "Use visual_files")
    galleries: [Gallery!]!
    id: ID!
    o_counter: Int
    organized: Boolean!
    path: String! @deprecated(reason: "Use files.path")
    paths: ImagePathsType!
    performers: [Performer!]!
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    studio: Studio
    tags: [Tag!]!
    title: String
    updated_at: Time!
    url: String @deprecated(reason: "Use urls")
    urls: [String!]!
    visual_files: [VisualFile!]!
}

type ImageFile implements BaseFile {
    basename: String!
    created_at: Time!
    fingerprints: [Fingerprint!]!
    height: Int!
    id: ID!
    mod_time: Time!
    parent_folder_id: ID!
    path: String!
    size: Int64!
    updated_at: Time!
    width: Int!
    zip_file_id: ID
}

type ImageFileType {
    height: Int!
    mod_time: Time!
    size: Int!
    width: Int!
}

type ImagePathsType {
    image: String
    preview: String
    thumbnail: String
}

type Job {
    addTime: Time!
    description: String!
    endTime: Time
    id: ID!
    progress: Float
    startTime: Time
    status: JobStatus!
    subTasks: [String!]
}

type JobStatusUpdate {
    job: Job!
    type: JobStatusUpdateType!
}

type LatestVersion {
    release_date: String!
    shorthash: String!
    url: String!
    version: String!
}

type LogEntry {
    level: LogLevel!
    message: String!
    time: Time!
}

type MarkerStringsResultType {
    count: Int!
    id: ID!
    title: String!
}

type Movie {
    aliases: String
    back_image_path: String
    checksum: String! @deprecated(reason: "MD5 hash of name, use name directly")
    created_at: Time!
    date: String
    director: String
    "Duration in seconds"
    duration: Int
    front_image_path: String
    id: ID!
    name: String!
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    scene_count: Int!
    scenes: [Scene!]!
    studio: Studio
    synopsis: String
    updated_at: Time!
    url: String
}

type Mutation {
    addGalleryImages(input: GalleryAddInput!): Boolean!
    "Enables an IP address for DLNA for an optional duration"
    addTempDLNAIP(input: AddTempDLNAIPInput!): Boolean!
    "Anonymise the database in a separate file. Optionally returns a link to download the database file"
    anonymiseDatabase(input: AnonymiseDatabaseInput!): String
    "Backup the database. Optionally returns a link to download the database file"
    backupDatabase(input: BackupDatabaseInput!): String
    bulkGalleryUpdate(input: BulkGalleryUpdateInput!): [Gallery!]
    bulkImageUpdate(input: BulkImageUpdateInput!): [Image!]
    bulkMovieUpdate(input: BulkMovieUpdateInput!): [Movie!]
    bulkPerformerUpdate(input: BulkPerformerUpdateInput!): [Performer!]
    bulkSceneUpdate(input: BulkSceneUpdateInput!): [Scene!]
    configureDLNA(input: ConfigDLNAInput!): ConfigDLNAResult!
    configureDefaults(input: ConfigDefaultSettingsInput!): ConfigDefaultSettingsResult!
    "Change general configuration options"
    configureGeneral(input: ConfigGeneralInput!): ConfigGeneralResult!
    configureInterface(input: ConfigInterfaceInput!): ConfigInterfaceResult!
    configureScraping(input: ConfigScrapingInput!): ConfigScrapingResult!
    configureUI(input: Map!): Map!
    configureUISetting(key: String!, value: Any): Map!
    deleteFiles(ids: [ID!]!): Boolean!
    destroySavedFilter(input: DestroyFilterInput!): Boolean!
    "Disables DLNA for an optional duration. Has no effect if DLNA is disabled by default"
    disableDLNA(input: DisableDLNAInput!): Boolean!
    "Enables DLNA for an optional duration. Has no effect if DLNA is enabled by default"
    enableDLNA(input: EnableDLNAInput!): Boolean!
    "DANGEROUS: Execute an arbitrary SQL statement without returning any rows."
    execSQL(args: [Any], sql: String!): SQLExecResult!
    "Returns a link to download the result"
    exportObjects(input: ExportObjectsInput!): String
    galleriesUpdate(input: [GalleryUpdateInput!]!): [Gallery]
    galleryChapterCreate(input: GalleryChapterCreateInput!): GalleryChapter
    galleryChapterDestroy(id: ID!): Boolean!
    galleryChapterUpdate(input: GalleryChapterUpdateInput!): GalleryChapter
    galleryCreate(input: GalleryCreateInput!): Gallery
    galleryDestroy(input: GalleryDestroyInput!): Boolean!
    galleryUpdate(input: GalleryUpdateInput!): Gallery
    "Generate and set (or clear) API key"
    generateAPIKey(input: GenerateAPIKeyInput!): String!
    "Decrements the o-counter for an image. Returns the new value"
    imageDecrementO(id: ID!): Int!
    imageDestroy(input: ImageDestroyInput!): Boolean!
    "Increments the o-counter for an image. Returns the new value"
    imageIncrementO(id: ID!): Int!
    "Resets the o-counter for a image to 0. Returns the new value"
    imageResetO(id: ID!): Int!
    imageUpdate(input: ImageUpdateInput!): Image
    imagesDestroy(input: ImagesDestroyInput!): Boolean!
    imagesUpdate(input: [ImageUpdateInput!]!): [Image]
    "Performs an incremental import. Returns the job ID"
    importObjects(input: ImportObjectsInput!): ID!
    "Start auto-tagging. Returns the job ID"
    metadataAutoTag(input: AutoTagMetadataInput!): ID!
    "Clean metadata. Returns the job ID"
    metadataClean(input: CleanMetadataInput!): ID!
    "Start a full export. Outputs to the metadata directory. Returns the job ID"
    metadataExport: ID!
    "Start generating content. Returns the job ID"
    metadataGenerate(input: GenerateMetadataInput!): ID!
    "Identifies scenes using scrapers. Returns the job ID"
    metadataIdentify(input: IdentifyMetadataInput!): ID!
    "Start an full import. Completely wipes the database and imports from the metadata directory. Returns the job ID"
    metadataImport: ID!
    "Start a scan. Returns the job ID"
    metadataScan(input: ScanMetadataInput!): ID!
    migrate(input: MigrateInput!): Boolean!
    "Migrates blobs from the old storage system to the current one"
    migrateBlobs(input: MigrateBlobsInput!): ID!
    "Migrate generated files for the current hash naming"
    migrateHashNaming: ID!
    "Migrates legacy scene screenshot files into the blob storage"
    migrateSceneScreenshots(input: MigrateSceneScreenshotsInput!): ID!
    """

    Moves the given files to the given destination. Returns true if successful.
    Either the destination_folder or destination_folder_id must be provided.
    If both are provided, the destination_folder_id takes precedence.
    Destination folder must be a subfolder of one of the stash library paths.
    If provided, destination_basename must be a valid filename with an extension that
    matches one of the media extensions.
    Creates folder hierarchy if needed.
    """
    moveFiles(input: MoveFilesInput!): Boolean!
    movieCreate(input: MovieCreateInput!): Movie
    movieDestroy(input: MovieDestroyInput!): Boolean!
    movieUpdate(input: MovieUpdateInput!): Movie
    moviesDestroy(ids: [ID!]!): Boolean!
    "Optimises the database. Returns the job ID"
    optimiseDatabase: ID!
    performerCreate(input: PerformerCreateInput!): Performer
    performerDestroy(input: PerformerDestroyInput!): Boolean!
    performerUpdate(input: PerformerUpdateInput!): Performer
    performersDestroy(ids: [ID!]!): Boolean!
    "DANGEROUS: Execute an arbitrary SQL statement that returns rows."
    querySQL(args: [Any], sql: String!): SQLQueryResult!
    reloadPlugins: Boolean!
    "Reload scrapers"
    reloadScrapers: Boolean!
    removeGalleryImages(input: GalleryRemoveInput!): Boolean!
    "Removes an IP address from the temporary DLNA whitelist"
    removeTempDLNAIP(input: RemoveTempDLNAIPInput!): Boolean!
    "Run plugin task. Returns the job ID"
    runPluginTask(args: [PluginArgInput!], plugin_id: ID!, task_name: String!): ID!
    saveFilter(input: SaveFilterInput!): SavedFilter!
    sceneAssignFile(input: AssignSceneFileInput!): Boolean!
    sceneCreate(input: SceneCreateInput!): Scene
    "Decrements the o-counter for a scene. Returns the new value"
    sceneDecrementO(id: ID!): Int!
    sceneDestroy(input: SceneDestroyInput!): Boolean!
    "Generates screenshot at specified time in seconds. Leave empty to generate default screenshot"
    sceneGenerateScreenshot(at: Float, id: ID!): String!
    "Increments the o-counter for a scene. Returns the new value"
    sceneIncrementO(id: ID!): Int!
    "Increments the play count for the scene. Returns the new play count value."
    sceneIncrementPlayCount(id: ID!): Int!
    sceneMarkerCreate(input: SceneMarkerCreateInput!): SceneMarker
    sceneMarkerDestroy(id: ID!): Boolean!
    sceneMarkerUpdate(input: SceneMarkerUpdateInput!): SceneMarker
    sceneMerge(input: SceneMergeInput!): Scene
    "Resets the o-counter for a scene to 0. Returns the new value"
    sceneResetO(id: ID!): Int!
    "Sets the resume time point (if provided) and adds the provided duration to the scene's play duration"
    sceneSaveActivity(id: ID!, playDuration: Float, resume_time: Float): Boolean!
    sceneUpdate(input: SceneUpdateInput!): Scene
    scenesDestroy(input: ScenesDestroyInput!): Boolean!
    scenesUpdate(input: [SceneUpdateInput!]!): [Scene]
    setDefaultFilter(input: SetDefaultFilterInput!): Boolean!
    setup(input: SetupInput!): Boolean!
    "Run batch performer tag task. Returns the job ID."
    stashBoxBatchPerformerTag(input: StashBoxBatchTagInput!): String!
    "Run batch studio tag task. Returns the job ID."
    stashBoxBatchStudioTag(input: StashBoxBatchTagInput!): String!
    stopAllJobs: Boolean!
    stopJob(job_id: ID!): Boolean!
    studioCreate(input: StudioCreateInput!): Studio
    studioDestroy(input: StudioDestroyInput!): Boolean!
    studioUpdate(input: StudioUpdateInput!): Studio
    studiosDestroy(ids: [ID!]!): Boolean!
    "Submit fingerprints to stash-box instance"
    submitStashBoxFingerprints(input: StashBoxFingerprintSubmissionInput!): Boolean!
    "Submit performer as draft to stash-box instance"
    submitStashBoxPerformerDraft(input: StashBoxDraftSubmissionInput!): ID
    "Submit scene as draft to stash-box instance"
    submitStashBoxSceneDraft(input: StashBoxDraftSubmissionInput!): ID
    tagCreate(input: TagCreateInput!): Tag
    tagDestroy(input: TagDestroyInput!): Boolean!
    tagUpdate(input: TagUpdateInput!): Tag
    tagsDestroy(ids: [ID!]!): Boolean!
    tagsMerge(input: TagsMergeInput!): Tag
}

type Performer {
    alias_list: [String!]!
    aliases: String @deprecated(reason: "Use alias_list")
    birthdate: String
    career_length: String
    checksum: String @deprecated(reason: "Not used")
    circumcised: CircumisedEnum
    country: String
    created_at: Time!
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    favorite: Boolean!
    gallery_count: Int!
    gender: GenderEnum
    hair_color: String
    height: String @deprecated(reason: "Use height_cm")
    height_cm: Int
    id: ID!
    ignore_auto_tag: Boolean!
    image_count: Int!
    image_path: String
    instagram: String
    measurements: String
    movie_count: Int!
    movies: [Movie!]!
    name: String!
    o_counter: Int
    penis_length: Float
    performer_count: Int!
    piercings: String
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    scene_count: Int!
    scenes: [Scene!]!
    stash_ids: [StashID!]!
    tags: [Tag!]!
    tattoos: String
    twitter: String
    updated_at: Time!
    url: String
    weight: Int
}

type Plugin {
    description: String
    hooks: [PluginHook!]
    id: ID!
    name: String!
    tasks: [PluginTask!]
    url: String
    version: String
}

type PluginHook {
    description: String
    hooks: [String!]
    name: String!
    plugin: Plugin!
}

type PluginResult {
    error: String
    result: String
}

type PluginTask {
    description: String
    name: String!
    plugin: Plugin!
}

"The query root for this schema"
type Query {
    allGalleries: [Gallery!]!
    allImages: [Image!]!
    allMovies: [Movie!]!
    allPerformers: [Performer!]!
    allSceneMarkers: [SceneMarker!]!
    allScenes: [Scene!]!
    allStudios: [Studio!]!
    allTags: [Tag!]!
    "Returns the current, complete configuration"
    configuration: ConfigResult!
    "Returns an array of paths for the given path"
    directory(
        "Desired collation locale. Determines the order of the directory result. eg. 'en-US', 'pt-BR', ..."
        locale: String = "en",
        "The directory path to list"
        path: String
    ): Directory!
    dlnaStatus: DLNAStatus!
    findDefaultFilter(mode: FilterMode!): SavedFilter
    """

    Returns any groups of scenes that are perceptual duplicates within the queried distance
    and the difference between their duration is smaller than durationDiff
    """
    findDuplicateScenes(
        distance: Int,
        """

        Max difference in seconds between files in order to be considered for similarity matching.
        Fractional seconds are ok: 0.5 will mean only files that have durations within 0.5 seconds between them will be matched based on PHash distance.
        """
        duration_diff: Float
    ): [[Scene!]!]!
    findGalleries(filter: FindFilterType, gallery_filter: GalleryFilterType): FindGalleriesResultType!
    findGallery(id: ID!): Gallery
    findImage(checksum: String, id: ID): Image
    "A function which queries Scene objects"
    findImages(filter: FindFilterType, image_filter: ImageFilterType, image_ids: [Int!]): FindImagesResultType!
    findJob(input: FindJobInput!): Job
    "Find a movie by ID"
    findMovie(id: ID!): Movie
    "A function which queries Movie objects"
    findMovies(filter: FindFilterType, movie_filter: MovieFilterType): FindMoviesResultType!
    "Find a performer by ID"
    findPerformer(id: ID!): Performer
    "A function which queries Performer objects"
    findPerformers(filter: FindFilterType, performer_filter: PerformerFilterType, performer_ids: [Int!]): FindPerformersResultType!
    findSavedFilter(id: ID!): SavedFilter
    findSavedFilters(mode: FilterMode): [SavedFilter!]!
    "Find a scene by ID or Checksum"
    findScene(checksum: String, id: ID): Scene
    findSceneByHash(input: SceneHashInput!): Scene
    "A function which queries SceneMarker objects"
    findSceneMarkers(filter: FindFilterType, scene_marker_filter: SceneMarkerFilterType): FindSceneMarkersResultType!
    "A function which queries Scene objects"
    findScenes(filter: FindFilterType, scene_filter: SceneFilterType, scene_ids: [Int!]): FindScenesResultType!
    findScenesByPathRegex(filter: FindFilterType): FindScenesResultType!
    "Find a studio by ID"
    findStudio(id: ID!): Studio
    "A function which queries Studio objects"
    findStudios(filter: FindFilterType, studio_filter: StudioFilterType): FindStudiosResultType!
    findTag(id: ID!): Tag
    findTags(filter: FindFilterType, tag_filter: TagFilterType): FindTagsResultType!
    jobQueue: [Job!]
    latestversion: LatestVersion!
    listGalleryScrapers: [Scraper!]! @deprecated(reason: "Use listScrapers(types: [GALLERY])")
    listMovieScrapers: [Scraper!]! @deprecated(reason: "Use listScrapers(types: [MOVIE])")
    listPerformerScrapers: [Scraper!]! @deprecated(reason: "Use listScrapers(types: [PERFORMER])")
    listSceneScrapers: [Scraper!]! @deprecated(reason: "Use listScrapers(types: [SCENE])")
    "List available scrapers"
    listScrapers(types: [ScrapeContentType!]!): [Scraper!]!
    logs: [LogEntry!]!
    "Get marker strings"
    markerStrings(q: String, sort: String): [MarkerStringsResultType]!
    "Retrieve random scene markers for the wall"
    markerWall(q: String): [SceneMarker!]!
    parseSceneFilenames(config: SceneParserInput!, filter: FindFilterType): SceneParserResultType!
    "List available plugin operations"
    pluginTasks: [PluginTask!]
    "List loaded plugins"
    plugins: [Plugin!]
    "Organize scene markers by tag for a given scene ID"
    sceneMarkerTags(scene_id: ID!): [SceneMarkerTag!]!
    "Return valid stream paths"
    sceneStreams(id: ID): [SceneStreamEndpoint!]!
    "Retrieve random scenes for the wall"
    sceneWall(q: String): [Scene!]!
    "Scrape a list of performers from a query"
    scrapeFreeonesPerformerList(query: String!): [String!]! @deprecated(reason: "use scrapeSinglePerformer with scraper_id = builtin_freeones")
    "Scrapes a complete gallery record based on an existing gallery"
    scrapeGallery(gallery: GalleryUpdateInput!, scraper_id: ID!): ScrapedGallery @deprecated(reason: "use scrapeSingleGallery")
    "Scrapes a complete gallery record based on a URL"
    scrapeGalleryURL(url: String!): ScrapedGallery
    "Scrapes a complete movie record based on a URL"
    scrapeMovieURL(url: String!): ScrapedMovie
    "Scrape for multiple performers"
    scrapeMultiPerformers(input: ScrapeMultiPerformersInput!, source: ScraperSourceInput!): [[ScrapedPerformer!]!]!
    "Scrape for multiple scenes"
    scrapeMultiScenes(input: ScrapeMultiScenesInput!, source: ScraperSourceInput!): [[ScrapedScene!]!]!
    "Scrapes a complete performer record based on a scrapePerformerList result"
    scrapePerformer(scraped_performer: ScrapedPerformerInput!, scraper_id: ID!): ScrapedPerformer @deprecated(reason: "use scrapeSinglePerformer")
    "Scrape a list of performers based on name"
    scrapePerformerList(query: String!, scraper_id: ID!): [ScrapedPerformer!]! @deprecated(reason: "use scrapeSinglePerformer")
    "Scrapes a complete performer record based on a URL"
    scrapePerformerURL(url: String!): ScrapedPerformer
    "Scrapes a complete scene record based on an existing scene"
    scrapeScene(scene: SceneUpdateInput!, scraper_id: ID!): ScrapedScene @deprecated(reason: "use scrapeSingleScene")
    "Scrapes a complete scene record based on a URL"
    scrapeSceneURL(url: String!): ScrapedScene
    "Scrape for a single gallery"
    scrapeSingleGallery(input: ScrapeSingleGalleryInput!, source: ScraperSourceInput!): [ScrapedGallery!]!
    "Scrape for a single movie"
    scrapeSingleMovie(input: ScrapeSingleMovieInput!, source: ScraperSourceInput!): [ScrapedMovie!]!
    "Scrape for a single performer"
    scrapeSinglePerformer(input: ScrapeSinglePerformerInput!, source: ScraperSourceInput!): [ScrapedPerformer!]!
    "Scrape for a single scene"
    scrapeSingleScene(input: ScrapeSingleSceneInput!, source: ScraperSourceInput!): [ScrapedScene!]!
    "Scrape for a single studio"
    scrapeSingleStudio(input: ScrapeSingleStudioInput!, source: ScraperSourceInput!): [ScrapedStudio!]!
    "Scrapes content based on a URL"
    scrapeURL(ty: ScrapeContentType!, url: String!): ScrapedContent
    "Get stats"
    stats: StatsResultType!
    systemStatus: SystemStatus!
    validateStashBoxCredentials(input: StashBoxInput!): StashBoxValidationResult!
    version: Version!
}

type SQLExecResult {
    """

    The integer generated by the database in response to a command.
    Typically this will be from an "auto increment" column when inserting a new row.
    Not all databases support this feature, and the syntax of such statements varies.
    """
    last_insert_id: Int64
    """

    The number of rows affected by the query, usually an UPDATE, INSERT, or DELETE.
    Not all queries or databases support this feature.
    """
    rows_affected: Int64
}

type SQLQueryResult {
    "The column names, in the order they appear in the result set."
    columns: [String!]!
    "The returned rows."
    rows: [[Any]!]!
}

type SavedFilter {
    "JSON-encoded filter string"
    filter: String! @deprecated(reason: "use find_filter and object_filter instead")
    find_filter: SavedFindFilterType
    id: ID!
    mode: FilterMode!
    name: String!
    object_filter: Map
    ui_options: Map
}

type SavedFindFilterType {
    direction: SortDirectionEnum
    page: Int
    "use per_page = -1 to indicate all results. Defaults to 25."
    per_page: Int
    q: String
    sort: String
}

type ScanMetadataOptions {
    "Generate image clip previews during scan"
    scanGenerateClipPreviews: Boolean!
    "Generate covers during scan"
    scanGenerateCovers: Boolean!
    "Generate image previews during scan"
    scanGenerateImagePreviews: Boolean!
    "Generate phashes during scan"
    scanGeneratePhashes: Boolean!
    "Generate previews during scan"
    scanGeneratePreviews: Boolean!
    "Generate sprites during scan"
    scanGenerateSprites: Boolean!
    "Generate image thumbnails during scan"
    scanGenerateThumbnails: Boolean!
    "Strip file extension from title"
    stripFileExtension: Boolean! @deprecated(reason: "Not implemented")
    "Set name, date, details from metadata (if present)"
    useFileMetadata: Boolean! @deprecated(reason: "Not implemented")
}

type Scene {
    captions: [VideoCaption!]
    checksum: String @deprecated(reason: "Use files.fingerprints")
    code: String
    created_at: Time!
    date: String
    details: String
    director: String
    file: SceneFileType! @deprecated(reason: "Use files")
    file_mod_time: Time
    files: [VideoFile!]!
    galleries: [Gallery!]!
    id: ID!
    interactive: Boolean!
    interactive_speed: Int
    "The last time play count was updated"
    last_played_at: Time
    movies: [SceneMovie!]!
    o_counter: Int
    organized: Boolean!
    oshash: String @deprecated(reason: "Use files.fingerprints")
    path: String! @deprecated(reason: "Use files.path")
    paths: ScenePathsType!
    performers: [Performer!]!
    phash: String @deprecated(reason: "Use files.fingerprints")
    "The number ot times a scene has been played"
    play_count: Int
    "The total time a scene has spent playing"
    play_duration: Float
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    "The time index a scene was left at"
    resume_time: Float
    "Return valid stream paths"
    sceneStreams: [SceneStreamEndpoint!]!
    scene_markers: [SceneMarker!]!
    stash_ids: [StashID!]!
    studio: Studio
    tags: [Tag!]!
    title: String
    updated_at: Time!
    url: String @deprecated(reason: "Use urls")
    urls: [String!]!
}

type SceneFileType {
    audio_codec: String
    bitrate: Int
    duration: Float
    framerate: Float
    height: Int
    size: String
    video_codec: String
    width: Int
}

type SceneMarker {
    created_at: Time!
    id: ID!
    "The path to the preview image for this marker"
    preview: String!
    primary_tag: Tag!
    scene: Scene!
    "The path to the screenshot image for this marker"
    screenshot: String!
    seconds: Float!
    "The path to stream this marker"
    stream: String!
    tags: [Tag!]!
    title: String!
    updated_at: Time!
}

type SceneMarkerTag {
    scene_markers: [SceneMarker!]!
    tag: Tag!
}

type SceneMovie {
    movie: Movie!
    scene_index: Int
}

type SceneMovieID {
    movie_id: ID!
    scene_index: String
}

type SceneParserResult {
    code: String
    date: String
    details: String
    director: String
    gallery_ids: [ID!]
    movies: [SceneMovieID!]
    performer_ids: [ID!]
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    scene: Scene!
    studio_id: ID
    tag_ids: [ID!]
    title: String
    url: String
}

type SceneParserResultType {
    count: Int!
    results: [SceneParserResult!]!
}

type ScenePathsType {
    caption: String
    chapters_vtt: String @deprecated(reason: "No longer supported")
    funscript: String
    interactive_heatmap: String
    preview: String
    screenshot: String
    sprite: String
    stream: String
    vtt: String
    webp: String
}

type SceneStreamEndpoint {
    label: String
    mime_type: String
    url: String!
}

type ScrapedGallery {
    date: String
    details: String
    performers: [ScrapedPerformer!]
    studio: ScrapedStudio
    tags: [ScrapedTag!]
    title: String
    url: String @deprecated(reason: "use urls")
    urls: [String!]
}

"A movie from a scraping operation..."
type ScrapedMovie {
    aliases: String
    "This should be a base64 encoded data URL"
    back_image: String
    date: String
    director: String
    duration: String
    "This should be a base64 encoded data URL"
    front_image: String
    name: String
    rating: String
    stored_id: ID
    studio: ScrapedStudio
    synopsis: String
    url: String
}

"A performer from a scraping operation..."
type ScrapedPerformer {
    aliases: String
    birthdate: String
    career_length: String
    circumcised: String
    country: String
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    gender: String
    hair_color: String
    height: String
    "This should be a base64 encoded data URL"
    image: String @deprecated(reason: "use images instead")
    images: [String!]
    instagram: String
    measurements: String
    name: String
    penis_length: String
    piercings: String
    remote_site_id: String
    "Set if performer matched"
    stored_id: ID
    tags: [ScrapedTag!]
    tattoos: String
    twitter: String
    url: String
    weight: String
}

type ScrapedScene {
    code: String
    date: String
    details: String
    director: String
    duration: Int
    file: SceneFileType
    fingerprints: [StashBoxFingerprint!]
    "This should be a base64 encoded data URL"
    image: String
    movies: [ScrapedMovie!]
    performers: [ScrapedPerformer!]
    remote_site_id: String
    studio: ScrapedStudio
    tags: [ScrapedTag!]
    title: String
    url: String @deprecated(reason: "use urls")
    urls: [String!]
}

type ScrapedStudio {
    image: String
    name: String!
    parent: ScrapedStudio
    remote_site_id: String
    "Set if studio matched"
    stored_id: ID
    url: String
}

type ScrapedTag {
    name: String!
    "Set if tag matched"
    stored_id: ID
}

type Scraper {
    "Details for gallery scraper"
    gallery: ScraperSpec
    id: ID!
    "Details for movie scraper"
    movie: ScraperSpec
    name: String!
    "Details for performer scraper"
    performer: ScraperSpec
    "Details for scene scraper"
    scene: ScraperSpec
}

type ScraperSource {
    "Scraper ID to scrape with. Should be unset if stash_box_index is set"
    scraper_id: ID
    "Stash-box endpoint"
    stash_box_endpoint: String
    "Index of the configured stash-box instance to use. Should be unset if scraper_id is set"
    stash_box_index: Int @deprecated(reason: "use stash_box_endpoint")
}

type ScraperSpec {
    supported_scrapes: [ScrapeType!]!
    "URLs matching these can be scraped with"
    urls: [String!]
}

type StashBox {
    api_key: String!
    endpoint: String!
    name: String!
}

type StashBoxFingerprint {
    algorithm: String!
    duration: Int!
    hash: String!
}

type StashBoxPerformerQueryResult {
    query: String!
    results: [ScrapedPerformer!]!
}

type StashBoxValidationResult {
    status: String!
    valid: Boolean!
}

type StashConfig {
    excludeImage: Boolean!
    excludeVideo: Boolean!
    path: String!
}

type StashID {
    endpoint: String!
    stash_id: String!
}

type StatsResultType {
    gallery_count: Int!
    image_count: Int!
    images_size: Float!
    movie_count: Int!
    performer_count: Int!
    scene_count: Int!
    scenes_duration: Float!
    scenes_played: Int!
    scenes_size: Float!
    studio_count: Int!
    tag_count: Int!
    total_o_count: Int!
    total_play_count: Int!
    total_play_duration: Float!
}

type Studio {
    aliases: [String!]!
    checksum: String! @deprecated(reason: "MD5 hash of name, use name directly")
    child_studios: [Studio!]!
    created_at: Time!
    details: String
    gallery_count(depth: Int): Int!
    id: ID!
    ignore_auto_tag: Boolean!
    image_count(depth: Int): Int!
    image_path: String
    movie_count(depth: Int): Int!
    movies: [Movie!]!
    name: String!
    parent_studio: Studio
    performer_count(depth: Int): Int!
    rating: Int @deprecated(reason: "Use 1-100 range with rating100")
    rating100: Int
    scene_count(depth: Int): Int!
    stash_ids: [StashID!]!
    updated_at: Time!
    url: String
}

type Subscription {
    "Update from the metadata manager"
    jobsSubscribe: JobStatusUpdate!
    loggingSubscribe: [LogEntry!]!
    scanCompleteSubscribe: Boolean!
}

type SystemStatus {
    appSchema: Int!
    configPath: String
    databasePath: String
    databaseSchema: Int
    status: SystemStatusEnum!
}

type Tag {
    aliases: [String!]!
    child_count: Int!
    children: [Tag!]!
    created_at: Time!
    description: String
    gallery_count(depth: Int): Int!
    id: ID!
    ignore_auto_tag: Boolean!
    image_count(depth: Int): Int!
    image_path: String
    name: String!
    parent_count: Int!
    parents: [Tag!]!
    performer_count(depth: Int): Int!
    scene_count(depth: Int): Int!
    scene_marker_count(depth: Int): Int!
    updated_at: Time!
}

type Version {
    build_time: String!
    hash: String!
    version: String
}

type VideoCaption {
    caption_type: String!
    language_code: String!
}

type VideoFile implements BaseFile {
    audio_codec: String!
    basename: String!
    bit_rate: Int!
    created_at: Time!
    duration: Float!
    fingerprints: [Fingerprint!]!
    format: String!
    frame_rate: Float!
    height: Int!
    id: ID!
    mod_time: Time!
    parent_folder_id: ID!
    path: String!
    size: Int64!
    updated_at: Time!
    video_codec: String!
    width: Int!
    zip_file_id: ID
}

enum BlobsStorageType {
    "Database"
    DATABASE
    "Filesystem"
    FILESYSTEM
}

enum BulkUpdateIdMode {
    ADD
    REMOVE
    SET
}

enum CircumisedEnum {
    CUT
    UNCUT
}

enum CriterionModifier {
    ">= AND <="
    BETWEEN
    "="
    EQUALS
    EXCLUDES
    ">"
    GREATER_THAN
    INCLUDES
    "INCLUDES ALL"
    INCLUDES_ALL
    "IS NULL"
    IS_NULL
    "<"
    LESS_THAN
    "MATCHES REGEX"
    MATCHES_REGEX
    "< OR >"
    NOT_BETWEEN
    "!="
    NOT_EQUALS
    "NOT MATCHES REGEX"
    NOT_MATCHES_REGEX
    "IS NOT NULL"
    NOT_NULL
}

enum FilterMode {
    GALLERIES
    IMAGES
    MOVIES
    PERFORMERS
    SCENES
    SCENE_MARKERS
    STUDIOS
    TAGS
}

enum GenderEnum {
    FEMALE
    INTERSEX
    MALE
    NON_BINARY
    TRANSGENDER_FEMALE
    TRANSGENDER_MALE
}

enum HashAlgorithm {
    MD5
    "oshash"
    OSHASH
}

enum IdentifyFieldStrategy {
    "Never sets the field value"
    IGNORE
    """

    For multi-value fields, merge with existing.
    For single-value fields, ignore if already set
    """
    MERGE
    """

    Always replaces the value if a value is found.
    For multi-value fields, any existing values are removed and replaced with the
    scraped values.
    """
    OVERWRITE
}

enum ImageLightboxDisplayMode {
    FIT_X
    FIT_XY
    ORIGINAL
}

enum ImageLightboxScrollMode {
    PAN_Y
    ZOOM
}

enum ImportDuplicateEnum {
    FAIL
    IGNORE
    OVERWRITE
}

enum ImportMissingRefEnum {
    CREATE
    FAIL
    IGNORE
}

enum JobStatus {
    CANCELLED
    FINISHED
    READY
    RUNNING
    STOPPING
}

enum JobStatusUpdateType {
    ADD
    REMOVE
    UPDATE
}

enum LogLevel {
    Debug
    Error
    Info
    Progress
    Trace
    Warning
}

enum PreviewPreset {
    "X264_FAST"
    fast
    "X264_MEDIUM"
    medium
    "X264_SLOW"
    slow
    "X264_SLOWER"
    slower
    "X264_ULTRAFAST"
    ultrafast
    "X264_VERYFAST"
    veryfast
    "X264_VERYSLOW"
    veryslow
}

enum ResolutionEnum {
    "8K"
    EIGHT_K
    "5K"
    FIVE_K
    "4K"
    FOUR_K
    "1080p"
    FULL_HD
    "8K+"
    HUGE
    "240p"
    LOW
    "1440p"
    QUAD_HD
    "360p"
    R360P
    "7K"
    SEVEN_K
    "6K"
    SIX_K
    "480p"
    STANDARD
    "720p"
    STANDARD_HD
    "144p"
    VERY_LOW
    "1920p"
    VR_HD @deprecated(reason: "Use 4K instead")
    "540p"
    WEB_HD
}

"Type of the content a scraper generates"
enum ScrapeContentType {
    GALLERY
    MOVIE
    PERFORMER
    SCENE
}

enum ScrapeType {
    "From existing object"
    FRAGMENT
    "From text query"
    NAME
    "From URL"
    URL
}

enum SortDirectionEnum {
    ASC
    DESC
}

enum StreamingResolutionEnum {
    "4k"
    FOUR_K
    "1080p"
    FULL_HD
    "240p"
    LOW
    "Original"
    ORIGINAL
    "480p"
    STANDARD
    "720p"
    STANDARD_HD
}

enum SystemStatusEnum {
    NEEDS_MIGRATION
    OK
    SETUP
}

scalar Any

scalar Int64

scalar Map

"Log entries"
scalar Time

"""

Timestamp is a point in time. It is always output as RFC3339-compatible time points.
It can be input as a RFC3339 string, or as "<4h" for "4 hours in the past" or ">5m"
for "5 minutes in the future"
"""
scalar Timestamp

scalar Upload

input AddTempDLNAIPInput {
    address: String!
    "Duration to enable, in minutes. 0 or null for indefinite."
    duration: Int
}

input AnonymiseDatabaseInput {
    download: Boolean
}

input AssignSceneFileInput {
    file_id: ID!
    scene_id: ID!
}

input AutoTagMetadataInput {
    "Paths to tag, null for all files"
    paths: [String!]
    "IDs of performers to tag files with, or \"*\" for all"
    performers: [String!]
    "IDs of studios to tag files with, or \"*\" for all"
    studios: [String!]
    "IDs of tags to tag files with, or \"*\" for all"
    tags: [String!]
}

input BackupDatabaseInput {
    download: Boolean
}

input BulkGalleryUpdateInput {
    clientMutationId: String
    date: String
    details: String
    ids: [ID!]
    organized: Boolean
    performer_ids: BulkUpdateIds
    rating: Int
    rating100: Int
    scene_ids: BulkUpdateIds
    studio_id: ID
    tag_ids: BulkUpdateIds
    url: String
    urls: BulkUpdateStrings
}

input BulkImageUpdateInput {
    clientMutationId: String
    date: String
    gallery_ids: BulkUpdateIds
    ids: [ID!]
    organized: Boolean
    performer_ids: BulkUpdateIds
    rating: Int
    rating100: Int
    studio_id: ID
    tag_ids: BulkUpdateIds
    title: String
    url: String
    urls: BulkUpdateStrings
}

input BulkMovieUpdateInput {
    clientMutationId: String
    director: String
    ids: [ID!]
    rating: Int
    rating100: Int
    studio_id: ID
}

input BulkPerformerUpdateInput {
    alias_list: BulkUpdateStrings
    aliases: String
    birthdate: String
    career_length: String
    circumcised: CircumisedEnum
    clientMutationId: String
    country: String
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    favorite: Boolean
    gender: GenderEnum
    hair_color: String
    height: String
    height_cm: Int
    ids: [ID!]
    ignore_auto_tag: Boolean
    instagram: String
    measurements: String
    penis_length: Float
    piercings: String
    rating: Int
    rating100: Int
    tag_ids: BulkUpdateIds
    tattoos: String
    twitter: String
    url: String
    weight: Int
}

input BulkSceneUpdateInput {
    clientMutationId: String
    code: String
    date: String
    details: String
    director: String
    gallery_ids: BulkUpdateIds
    ids: [ID!]
    movie_ids: BulkUpdateIds
    organized: Boolean
    performer_ids: BulkUpdateIds
    rating: Int
    rating100: Int
    studio_id: ID
    tag_ids: BulkUpdateIds
    title: String
    url: String
    urls: BulkUpdateStrings
}

input BulkUpdateIds {
    ids: [ID!]
    mode: BulkUpdateIdMode!
}

input BulkUpdateStrings {
    mode: BulkUpdateIdMode!
    values: [String!]
}

input CircumcisionCriterionInput {
    modifier: CriterionModifier!
    value: [CircumisedEnum!]
}

input CleanMetadataInput {
    "Do a dry run. Don't delete any files"
    dryRun: Boolean!
    paths: [String!]
}

input ConfigDLNAInput {
    "True if DLNA service should be enabled by default"
    enabled: Boolean
    "List of interfaces to run DLNA on. Empty for all"
    interfaces: [String!]
    serverName: String
    "Order to sort videos"
    videoSortOrder: String
    "List of IPs whitelisted for DLNA service"
    whitelistedIPs: [String!]
}

input ConfigDefaultSettingsInput {
    autoTag: AutoTagMetadataInput
    "If true, delete file checkbox will be checked by default"
    deleteFile: Boolean
    "If true, delete generated files checkbox will be checked by default"
    deleteGenerated: Boolean
    generate: GenerateMetadataInput
    identify: IdentifyMetadataInput
    scan: ScanMetadataInput
}

input ConfigDisableDropdownCreateInput {
    movie: Boolean
    performer: Boolean
    studio: Boolean
    tag: Boolean
}

input ConfigGeneralInput {
    "Path to backup directory"
    backupDirectoryPath: String
    "Path to blobs - required for filesystem blob storage"
    blobsPath: String
    "Where to store blobs"
    blobsStorage: BlobsStorageType
    "Path to cache"
    cachePath: String
    "Whether to calculate MD5 checksums for scene video files"
    calculateMD5: Boolean
    "True if galleries should be created from folders with images"
    createGalleriesFromFolders: Boolean
    "Create Image Clips from Video extensions when Videos are disabled in Library"
    createImageClipsFromVideos: Boolean
    "Custom Performer Image Location"
    customPerformerImageLocation: String
    "Path to the SQLite database"
    databasePath: String
    "whether to include range in generated funscript heatmaps"
    drawFunscriptHeatmapRange: Boolean
    "Array of file regexp to exclude from Video Scans"
    excludes: [String!]
    "Regex used to identify images as gallery covers"
    galleryCoverRegex: String
    "Array of gallery zip file extensions"
    galleryExtensions: [String!]
    "Path to generated files"
    generatedPath: String
    "Array of file regexp to exclude from Image Scans"
    imageExcludes: [String!]
    "Array of image file extensions"
    imageExtensions: [String!]
    """

    ffmpeg stream input args - injected before input file
    These are applied when live transcoding
    """
    liveTranscodeInputArgs: [String!]
    """

    ffmpeg stream output args - injected before output file
    These are applied when live transcoding
    """
    liveTranscodeOutputArgs: [String!]
    "Whether to log http access"
    logAccess: Boolean
    "Name of the log file"
    logFile: String
    "Minimum log level"
    logLevel: String
    "Whether to also output to stderr"
    logOut: Boolean
    "Maximum session cookie age"
    maxSessionAge: Int
    "Max streaming transcode size"
    maxStreamingTranscodeSize: StreamingResolutionEnum
    "Max generated transcode size"
    maxTranscodeSize: StreamingResolutionEnum
    "Path to import/export files"
    metadataPath: String
    "Number of parallel tasks to start during scan/generate"
    parallelTasks: Int
    "Password"
    password: String
    "Include audio stream in previews"
    previewAudio: Boolean
    "Duration of end of video to exclude when generating previews"
    previewExcludeEnd: String
    "Duration of start of video to exclude when generating previews"
    previewExcludeStart: String
    "Preset when generating preview"
    previewPreset: PreviewPreset
    "Preview segment duration, in seconds"
    previewSegmentDuration: Float
    "Number of segments in a preview file"
    previewSegments: Int
    "Python path - resolved using path if unset"
    pythonPath: String
    "Scraper CDP path. Path to chrome executable or remote address"
    scraperCDPPath: String
    "Whether the scraper should check for invalid certificates"
    scraperCertCheck: Boolean
    "Scraper user agent string"
    scraperUserAgent: String
    "Path to scrapers"
    scrapersPath: String
    "Stash-box instances used for tagging"
    stashBoxes: [StashBoxInput!]
    "Array of file paths to content"
    stashes: [StashConfigInput!]
    "Transcode Hardware Acceleration"
    transcodeHardwareAcceleration: Boolean
    """

    ffmpeg transcode input args - injected before input file
    These are applied to generated transcodes (previews and transcodes)
    """
    transcodeInputArgs: [String!]
    """

    ffmpeg transcode output args - injected before output file
    These are applied to generated transcodes (previews and transcodes)
    """
    transcodeOutputArgs: [String!]
    "Comma separated list of proxies to allow traffic from"
    trustedProxies: [String!]
    "Username"
    username: String
    "Array of video file extensions"
    videoExtensions: [String!]
    "Hash algorithm to use for generated file naming"
    videoFileNamingAlgorithm: HashAlgorithm
    "Write image thumbnails to disk when generating on the fly"
    writeImageThumbnails: Boolean
}

input ConfigImageLightboxInput {
    displayMode: ImageLightboxDisplayMode
    resetZoomOnNav: Boolean
    scaleUp: Boolean
    scrollAttemptsBeforeChange: Int
    scrollMode: ImageLightboxScrollMode
    slideshowDelay: Int
}

input ConfigInterfaceInput {
    "If true, video will autostart on load in the scene player"
    autostartVideo: Boolean
    "If true, video will autostart when loading from play random or play selected"
    autostartVideoOnPlaySelected: Boolean
    "If true, next scene in playlist will be played at video end by default"
    continuePlaylistDefault: Boolean
    "Custom CSS"
    css: String
    cssEnabled: Boolean
    "Custom Locales"
    customLocales: String
    customLocalesEnabled: Boolean
    "Set to true to disable creating new objects via the dropdown menus"
    disableDropdownCreate: ConfigDisableDropdownCreateInput
    "Funscript Time Offset"
    funscriptOffset: Int
    "Handy Connection Key"
    handyKey: String
    imageLightbox: ConfigImageLightboxInput
    "Custom Javascript"
    javascript: String
    javascriptEnabled: Boolean
    "Interface language"
    language: String
    "Maximum duration (in seconds) in which a scene video will loop in the scene player"
    maximumLoopDuration: Int
    "Ordered list of items that should be shown in the menu"
    menuItems: [String!]
    "True if we should not auto-open a browser window on startup"
    noBrowser: Boolean
    "True if we should send notifications to the desktop"
    notificationsEnabled: Boolean
    "Show scene scrubber by default"
    showScrubber: Boolean
    "If true, studio overlays will be shown as text instead of logo images"
    showStudioAsText: Boolean
    "Slideshow Delay"
    slideshowDelay: Int
    "Enable sound on mouseover previews"
    soundOnPreview: Boolean
    "Whether to use Stash Hosted Funscript"
    useStashHostedFunscript: Boolean
    "Wall playback type"
    wallPlayback: String
    "Show title and tags in wall view"
    wallShowTitle: Boolean
}

input ConfigScrapingInput {
    "Tags blacklist during scraping"
    excludeTagPatterns: [String!]
    "Scraper CDP path. Path to chrome executable or remote address"
    scraperCDPPath: String
    "Whether the scraper should check for invalid certificates"
    scraperCertCheck: Boolean
    "Scraper user agent string"
    scraperUserAgent: String
}

input DateCriterionInput {
    modifier: CriterionModifier!
    value: String!
    value2: String
}

input DestroyFilterInput {
    id: ID!
}

input DisableDLNAInput {
    "Duration to enable, in minutes. 0 or null for indefinite."
    duration: Int
}

input EnableDLNAInput {
    "Duration to enable, in minutes. 0 or null for indefinite."
    duration: Int
}

input ExportObjectTypeInput {
    all: Boolean
    ids: [String!]
}

input ExportObjectsInput {
    galleries: ExportObjectTypeInput
    images: ExportObjectTypeInput
    includeDependencies: Boolean
    movies: ExportObjectTypeInput
    performers: ExportObjectTypeInput
    scenes: ExportObjectTypeInput
    studios: ExportObjectTypeInput
    tags: ExportObjectTypeInput
}

input FindFilterType {
    direction: SortDirectionEnum
    page: Int
    "use per_page = -1 to indicate all results. Defaults to 25."
    per_page: Int
    q: String
    sort: String
}

input FindJobInput {
    id: ID!
}

input FloatCriterionInput {
    modifier: CriterionModifier!
    value: Float!
    value2: Float
}

input GalleryAddInput {
    gallery_id: ID!
    image_ids: [ID!]!
}

input GalleryChapterCreateInput {
    gallery_id: ID!
    image_index: Int!
    title: String!
}

input GalleryChapterUpdateInput {
    gallery_id: ID
    id: ID!
    image_index: Int
    title: String
}

input GalleryCreateInput {
    date: String
    details: String
    organized: Boolean
    performer_ids: [ID!]
    rating: Int
    rating100: Int
    scene_ids: [ID!]
    studio_id: ID
    tag_ids: [ID!]
    title: String!
    url: String
    urls: [String!]
}

input GalleryDestroyInput {
    """

    If true, then the zip file will be deleted if the gallery is zip-file-based.
    If gallery is folder-based, then any files not associated with other
    galleries will be deleted, along with the folder, if it is not empty.
    """
    delete_file: Boolean
    delete_generated: Boolean
    ids: [ID!]!
}

input GalleryFilterType {
    AND: GalleryFilterType
    NOT: GalleryFilterType
    OR: GalleryFilterType
    "Filter by average image resolution"
    average_resolution: ResolutionCriterionInput
    "Filter by file checksum"
    checksum: StringCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by date"
    date: DateCriterionInput
    details: StringCriterionInput
    "Filter by zip-file count"
    file_count: IntCriterionInput
    "Filter to only include galleries that have chapters. `true` or `false`"
    has_chapters: String
    id: IntCriterionInput
    "Filter by number of images in this gallery"
    image_count: IntCriterionInput
    "Filter to only include galleries missing this property"
    is_missing: String
    "Filter to include/exclude galleries that were created from zip"
    is_zip: Boolean
    "Filter by organized"
    organized: Boolean
    "Filter by path"
    path: StringCriterionInput
    "Filter galleries by performer age at time of gallery"
    performer_age: IntCriterionInput
    "Filter by performer count"
    performer_count: IntCriterionInput
    "Filter galleries that have performers that have been favorited"
    performer_favorite: Boolean
    "Filter to only include galleries with performers with these tags"
    performer_tags: HierarchicalMultiCriterionInput
    "Filter to only include galleries with these performers"
    performers: MultiCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter to only include galleries with this studio"
    studios: HierarchicalMultiCriterionInput
    "Filter by tag count"
    tag_count: IntCriterionInput
    "Filter to only include galleries with these tags"
    tags: HierarchicalMultiCriterionInput
    title: StringCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
}

input GalleryRemoveInput {
    gallery_id: ID!
    image_ids: [ID!]!
}

input GalleryUpdateInput {
    clientMutationId: String
    date: String
    details: String
    id: ID!
    organized: Boolean
    performer_ids: [ID!]
    primary_file_id: ID
    rating: Int
    rating100: Int
    scene_ids: [ID!]
    studio_id: ID
    tag_ids: [ID!]
    title: String
    url: String
    urls: [String!]
}

input GenderCriterionInput {
    modifier: CriterionModifier!
    value: GenderEnum
}

input GenerateAPIKeyInput {
    clear: Boolean
}

input GenerateMetadataInput {
    clipPreviews: Boolean
    covers: Boolean
    "Generate transcodes even if not required"
    forceTranscodes: Boolean
    imagePreviews: Boolean
    interactiveHeatmapsSpeeds: Boolean
    "marker ids to generate for"
    markerIDs: [ID!]
    markerImagePreviews: Boolean
    markerScreenshots: Boolean
    markers: Boolean
    "overwrite existing media"
    overwrite: Boolean
    phashes: Boolean
    previewOptions: GeneratePreviewOptionsInput
    previews: Boolean
    "scene ids to generate for"
    sceneIDs: [ID!]
    sprites: Boolean
    transcodes: Boolean
}

input GeneratePreviewOptionsInput {
    "Duration of end of video to exclude when generating previews"
    previewExcludeEnd: String
    "Duration of start of video to exclude when generating previews"
    previewExcludeStart: String
    "Preset when generating preview"
    previewPreset: PreviewPreset
    "Preview segment duration, in seconds"
    previewSegmentDuration: Float
    "Number of segments in a preview file"
    previewSegments: Int
}

input HierarchicalMultiCriterionInput {
    depth: Int
    excludes: [ID!]
    modifier: CriterionModifier!
    value: [ID!]
}

input IdentifyFieldOptionsInput {
    "creates missing objects if needed - only applicable for performers, tags and studios"
    createMissing: Boolean
    field: String!
    strategy: IdentifyFieldStrategy!
}

input IdentifyMetadataInput {
    "Options defined here override the configured defaults"
    options: IdentifyMetadataOptionsInput
    "paths of scenes to identify - ignored if scene ids are set"
    paths: [String!]
    "scene ids to identify"
    sceneIDs: [ID!]
    "An ordered list of sources to identify items with. Only the first source that finds a match is used."
    sources: [IdentifySourceInput!]!
}

input IdentifyMetadataOptionsInput {
    "any fields missing from here are defaulted to MERGE and createMissing false"
    fieldOptions: [IdentifyFieldOptionsInput!]
    "defaults to true if not provided"
    includeMalePerformers: Boolean
    "defaults to true if not provided"
    setCoverImage: Boolean
    setOrganized: Boolean
    "tag to tag skipped multiple matches with"
    skipMultipleMatchTag: String
    "defaults to true if not provided"
    skipMultipleMatches: Boolean
    "tag to tag skipped single name performers with"
    skipSingleNamePerformerTag: String
    "defaults to true if not provided"
    skipSingleNamePerformers: Boolean
}

input IdentifySourceInput {
    "Options defined for a source override the defaults"
    options: IdentifyMetadataOptionsInput
    source: ScraperSourceInput!
}

input ImageDestroyInput {
    delete_file: Boolean
    delete_generated: Boolean
    id: ID!
}

input ImageFilterType {
    AND: ImageFilterType
    NOT: ImageFilterType
    OR: ImageFilterType
    "Filter by file checksum"
    checksum: StringCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by date"
    date: DateCriterionInput
    "Filter by file count"
    file_count: IntCriterionInput
    "Filter to only include images with these galleries"
    galleries: MultiCriterionInput
    " Filter by image id"
    id: IntCriterionInput
    "Filter to only include images missing this property"
    is_missing: String
    "Filter by o-counter"
    o_counter: IntCriterionInput
    "Filter by organized"
    organized: Boolean
    "Filter by path"
    path: StringCriterionInput
    "Filter by performer count"
    performer_count: IntCriterionInput
    "Filter images that have performers that have been favorited"
    performer_favorite: Boolean
    "Filter to only include images with performers with these tags"
    performer_tags: HierarchicalMultiCriterionInput
    "Filter to only include images with these performers"
    performers: MultiCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter by resolution"
    resolution: ResolutionCriterionInput
    "Filter to only include images with this studio"
    studios: HierarchicalMultiCriterionInput
    "Filter by tag count"
    tag_count: IntCriterionInput
    "Filter to only include images with these tags"
    tags: HierarchicalMultiCriterionInput
    title: StringCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
}

input ImageUpdateInput {
    clientMutationId: String
    date: String
    gallery_ids: [ID!]
    id: ID!
    organized: Boolean
    performer_ids: [ID!]
    primary_file_id: ID
    rating: Int
    rating100: Int
    studio_id: ID
    tag_ids: [ID!]
    title: String
    url: String
    urls: [String!]
}

input ImagesDestroyInput {
    delete_file: Boolean
    delete_generated: Boolean
    ids: [ID!]!
}

input ImportObjectsInput {
    duplicateBehaviour: ImportDuplicateEnum!
    file: Upload!
    missingRefBehaviour: ImportMissingRefEnum!
}

input IntCriterionInput {
    modifier: CriterionModifier!
    value: Int!
    value2: Int
}

input MigrateBlobsInput {
    deleteOld: Boolean
}

input MigrateInput {
    backupPath: String!
}

input MigrateSceneScreenshotsInput {
    deleteFiles: Boolean
    overwriteExisting: Boolean
}

input MoveFilesInput {
    "valid only for single file id. If empty, existing basename is used"
    destination_basename: String
    "valid for single or multiple file ids"
    destination_folder: String
    "valid for single or multiple file ids"
    destination_folder_id: ID
    ids: [ID!]!
}

input MovieCreateInput {
    aliases: String
    "This should be a URL or a base64 encoded data URL"
    back_image: String
    date: String
    director: String
    "Duration in seconds"
    duration: Int
    "This should be a URL or a base64 encoded data URL"
    front_image: String
    name: String!
    rating: Int
    rating100: Int
    studio_id: ID
    synopsis: String
    url: String
}

input MovieDestroyInput {
    id: ID!
}

input MovieFilterType {
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by date"
    date: DateCriterionInput
    director: StringCriterionInput
    "Filter by duration (in seconds)"
    duration: IntCriterionInput
    "Filter to only include movies missing this property"
    is_missing: String
    name: StringCriterionInput
    "Filter to only include movies where performer appears in a scene"
    performers: MultiCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter to only include movies with this studio"
    studios: HierarchicalMultiCriterionInput
    synopsis: StringCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
}

input MovieUpdateInput {
    aliases: String
    "This should be a URL or a base64 encoded data URL"
    back_image: String
    date: String
    director: String
    duration: Int
    "This should be a URL or a base64 encoded data URL"
    front_image: String
    id: ID!
    name: String
    rating: Int
    rating100: Int
    studio_id: ID
    synopsis: String
    url: String
}

input MultiCriterionInput {
    excludes: [ID!]
    modifier: CriterionModifier!
    value: [ID!]
}

input PHashDuplicationCriterionInput {
    "Currently unimplemented"
    distance: Int
    duplicated: Boolean
}

input PerformerCreateInput {
    alias_list: [String!]
    aliases: String
    birthdate: String
    career_length: String
    circumcised: CircumisedEnum
    country: String
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    favorite: Boolean
    gender: GenderEnum
    hair_color: String
    height: String
    height_cm: Int
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    instagram: String
    measurements: String
    name: String!
    penis_length: Float
    piercings: String
    rating: Int
    rating100: Int
    stash_ids: [StashIDInput!]
    tag_ids: [ID!]
    tattoos: String
    twitter: String
    url: String
    weight: Int
}

input PerformerDestroyInput {
    id: ID!
}

input PerformerFilterType {
    AND: PerformerFilterType
    NOT: PerformerFilterType
    OR: PerformerFilterType
    "Filter by age"
    age: IntCriterionInput
    "Filter by aliases"
    aliases: StringCriterionInput
    "Filter by birth year"
    birth_year: IntCriterionInput
    "Filter by birthdate"
    birthdate: DateCriterionInput
    "Filter by career length"
    career_length: StringCriterionInput
    "Filter by ciricumcision"
    circumcised: CircumcisionCriterionInput
    "Filter by country"
    country: StringCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by death date"
    death_date: DateCriterionInput
    "Filter by death year"
    death_year: IntCriterionInput
    details: StringCriterionInput
    disambiguation: StringCriterionInput
    "Filter by ethnicity"
    ethnicity: StringCriterionInput
    "Filter by eye color"
    eye_color: StringCriterionInput
    "Filter by fake tits value"
    fake_tits: StringCriterionInput
    "Filter by favorite"
    filter_favorites: Boolean
    "Filter by gallery count"
    gallery_count: IntCriterionInput
    "Filter by gender"
    gender: GenderCriterionInput
    "Filter by hair color"
    hair_color: StringCriterionInput
    "Filter by height"
    height: StringCriterionInput
    "Filter by height in cm"
    height_cm: IntCriterionInput
    "Filter by autotag ignore value"
    ignore_auto_tag: Boolean
    "Filter by image count"
    image_count: IntCriterionInput
    "Filter to only include performers missing this property"
    is_missing: String
    "Filter by measurements"
    measurements: StringCriterionInput
    name: StringCriterionInput
    "Filter by o count"
    o_counter: IntCriterionInput
    "Filter by penis length value"
    penis_length: FloatCriterionInput
    "Filter by performers where performer appears with another performer in scene/image/gallery"
    performers: MultiCriterionInput
    "Filter by piercings"
    piercings: StringCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter by scene count"
    scene_count: IntCriterionInput
    "Filter by StashID"
    stash_id: StringCriterionInput
    "Filter by StashID"
    stash_id_endpoint: StashIDCriterionInput
    "Filter by studios where performer appears in scene/image/gallery"
    studios: HierarchicalMultiCriterionInput
    "Filter by tag count"
    tag_count: IntCriterionInput
    "Filter to only include performers with these tags"
    tags: HierarchicalMultiCriterionInput
    "Filter by tattoos"
    tattoos: StringCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
    "Filter by weight"
    weight: IntCriterionInput
}

input PerformerUpdateInput {
    alias_list: [String!]
    aliases: String
    birthdate: String
    career_length: String
    circumcised: CircumisedEnum
    country: String
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    favorite: Boolean
    gender: GenderEnum
    hair_color: String
    height: String
    height_cm: Int
    id: ID!
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    instagram: String
    measurements: String
    name: String
    penis_length: Float
    piercings: String
    rating: Int
    rating100: Int
    stash_ids: [StashIDInput!]
    tag_ids: [ID!]
    tattoos: String
    twitter: String
    url: String
    weight: Int
}

input PhashDistanceCriterionInput {
    distance: Int
    modifier: CriterionModifier!
    value: String!
}

input PluginArgInput {
    key: String!
    value: PluginValueInput
}

input PluginValueInput {
    a: [PluginValueInput!]
    b: Boolean
    f: Float
    i: Int
    o: [PluginArgInput!]
    str: String
}

input RemoveTempDLNAIPInput {
    address: String!
}

input ResolutionCriterionInput {
    modifier: CriterionModifier!
    value: ResolutionEnum!
}

input SaveFilterInput {
    find_filter: FindFilterType
    "provide ID to overwrite existing filter"
    id: ID
    mode: FilterMode!
    name: String!
    object_filter: Map
    ui_options: Map
}

"Filter options for meta data scannning"
input ScanMetaDataFilterInput {
    "If set, files with a modification time before this time point are ignored by the scan"
    minModTime: Timestamp
}

input ScanMetadataInput {
    "Filter options for the scan"
    filter: ScanMetaDataFilterInput
    paths: [String!]
    "Generate image clip previews during scan"
    scanGenerateClipPreviews: Boolean
    "Generate covers during scan"
    scanGenerateCovers: Boolean
    "Generate image previews during scan"
    scanGenerateImagePreviews: Boolean
    "Generate phashes during scan"
    scanGeneratePhashes: Boolean
    "Generate previews during scan"
    scanGeneratePreviews: Boolean
    "Generate sprites during scan"
    scanGenerateSprites: Boolean
    "Generate image thumbnails during scan"
    scanGenerateThumbnails: Boolean
    "Strip file extension from title"
    stripFileExtension: Boolean
    "Set name, date, details from metadata (if present)"
    useFileMetadata: Boolean
}

input SceneCreateInput {
    code: String
    "This should be a URL or a base64 encoded data URL"
    cover_image: String
    date: String
    details: String
    director: String
    """

    The first id will be assigned as primary.
    Files will be reassigned from existing scenes if applicable.
    Files must not already be primary for another scene.
    """
    file_ids: [ID!]
    gallery_ids: [ID!]
    movies: [SceneMovieInput!]
    organized: Boolean
    performer_ids: [ID!]
    rating: Int
    rating100: Int
    stash_ids: [StashIDInput!]
    studio_id: ID
    tag_ids: [ID!]
    title: String
    url: String
    urls: [String!]
}

input SceneDestroyInput {
    delete_file: Boolean
    delete_generated: Boolean
    id: ID!
}

input SceneFilterType {
    AND: SceneFilterType
    NOT: SceneFilterType
    OR: SceneFilterType
    "Filter by audio codec"
    audio_codec: StringCriterionInput
    "Filter by captions"
    captions: StringCriterionInput
    "Filter by file checksum"
    checksum: StringCriterionInput
    code: StringCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by date"
    date: DateCriterionInput
    details: StringCriterionInput
    director: StringCriterionInput
    "Filter Scenes that have an exact phash match available"
    duplicated: PHashDuplicationCriterionInput
    "Filter by duration (in seconds)"
    duration: IntCriterionInput
    "Filter by file count"
    file_count: IntCriterionInput
    "Filter to only include scenes which have markers. `true` or `false`"
    has_markers: String
    id: IntCriterionInput
    "Filter by interactive"
    interactive: Boolean
    "Filter by InteractiveSpeed"
    interactive_speed: IntCriterionInput
    "Filter to only include scenes missing this property"
    is_missing: String
    "Filter to only include scenes with this movie"
    movies: MultiCriterionInput
    "Filter by o-counter"
    o_counter: IntCriterionInput
    "Filter by organized"
    organized: Boolean
    "Filter by file oshash"
    oshash: StringCriterionInput
    "Filter by path"
    path: StringCriterionInput
    "Filter scenes by performer age at time of scene"
    performer_age: IntCriterionInput
    "Filter by performer count"
    performer_count: IntCriterionInput
    "Filter scenes that have performers that have been favorited"
    performer_favorite: Boolean
    "Filter to only include scenes with performers with these tags"
    performer_tags: HierarchicalMultiCriterionInput
    "Filter to only include scenes with these performers"
    performers: MultiCriterionInput
    "Filter by file phash"
    phash: StringCriterionInput
    "Filter by file phash distance"
    phash_distance: PhashDistanceCriterionInput
    "Filter by play count"
    play_count: IntCriterionInput
    "Filter by play duration (in seconds)"
    play_duration: IntCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter by resolution"
    resolution: ResolutionCriterionInput
    "Filter by frame rate"
    framerate: IntCriterionInput
    "Filter by resume time"
    resume_time: IntCriterionInput
    "Filter by StashID"
    stash_id: StringCriterionInput
    "Filter by StashID"
    stash_id_endpoint: StashIDCriterionInput
    "Filter to only include scenes with this studio"
    studios: HierarchicalMultiCriterionInput
    "Filter by tag count"
    tag_count: IntCriterionInput
    "Filter to only include scenes with these tags"
    tags: HierarchicalMultiCriterionInput
    title: StringCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
    "Filter by video codec"
    video_codec: StringCriterionInput
}

input SceneHashInput {
    checksum: String
    oshash: String
}

input SceneMarkerCreateInput {
    primary_tag_id: ID!
    scene_id: ID!
    seconds: Float!
    tag_ids: [ID!]
    title: String!
}

input SceneMarkerFilterType {
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter to only include scene markers with these performers"
    performers: MultiCriterionInput
    "Filter by cscene reation time"
    scene_created_at: TimestampCriterionInput
    "Filter by scene date"
    scene_date: DateCriterionInput
    "Filter to only include scene markers attached to a scene with these tags"
    scene_tags: HierarchicalMultiCriterionInput
    "Filter by lscene ast update time"
    scene_updated_at: TimestampCriterionInput
    "Filter to only include scene markers with this tag"
    tag_id: ID
    "Filter to only include scene markers with these tags"
    tags: HierarchicalMultiCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
}

input SceneMarkerUpdateInput {
    id: ID!
    primary_tag_id: ID
    scene_id: ID
    seconds: Float
    tag_ids: [ID!]
    title: String
}

input SceneMergeInput {
    destination: ID!
    """

    If destination scene has no files, then the primary file of the
    first source scene will be assigned as primary
    """
    source: [ID!]!
    values: SceneUpdateInput
}

input SceneMovieInput {
    movie_id: ID!
    scene_index: Int
}

input SceneParserInput {
    capitalizeTitle: Boolean
    ignoreOrganized: Boolean
    ignoreWords: [String!]
    whitespaceCharacters: String
}

input SceneUpdateInput {
    clientMutationId: String
    code: String
    "This should be a URL or a base64 encoded data URL"
    cover_image: String
    date: String
    details: String
    director: String
    gallery_ids: [ID!]
    id: ID!
    movies: [SceneMovieInput!]
    o_counter: Int
    organized: Boolean
    performer_ids: [ID!]
    "The number ot times a scene has been played"
    play_count: Int
    "The total time a scene has spent playing"
    play_duration: Float
    primary_file_id: ID
    rating: Int
    rating100: Int
    "The time index a scene was left at"
    resume_time: Float
    stash_ids: [StashIDInput!]
    studio_id: ID
    tag_ids: [ID!]
    title: String
    url: String
    urls: [String!]
}

input ScenesDestroyInput {
    delete_file: Boolean
    delete_generated: Boolean
    ids: [ID!]!
}

input ScrapeMultiPerformersInput {
    "Instructs to query by scene fingerprints"
    performer_ids: [ID!]
}

input ScrapeMultiScenesInput {
    "Instructs to query by scene fingerprints"
    scene_ids: [ID!]
}

input ScrapeSingleGalleryInput {
    "Instructs to query by gallery id"
    gallery_id: ID
    "Instructs to query by gallery fragment"
    gallery_input: ScrapedGalleryInput
    "Instructs to query by string"
    query: String
}

input ScrapeSingleMovieInput {
    "Instructs to query by movie id"
    movie_id: ID
    "Instructs to query by gallery fragment"
    movie_input: ScrapedMovieInput
    "Instructs to query by string"
    query: String
}

input ScrapeSinglePerformerInput {
    "Instructs to query by performer id"
    performer_id: ID
    "Instructs to query by performer fragment"
    performer_input: ScrapedPerformerInput
    "Instructs to query by string"
    query: String
}

input ScrapeSingleSceneInput {
    "Instructs to query by string"
    query: String
    "Instructs to query by scene fingerprints"
    scene_id: ID
    "Instructs to query by scene fragment"
    scene_input: ScrapedSceneInput
}

input ScrapeSingleStudioInput {
    "Query can be either a name or a Stash ID"
    query: String
}

input ScrapedGalleryInput {
    date: String
    details: String
    title: String
    url: String
    urls: [String!]
}

input ScrapedMovieInput {
    aliases: String
    date: String
    director: String
    duration: String
    name: String
    rating: String
    synopsis: String
    url: String
}

input ScrapedPerformerInput {
    aliases: String
    birthdate: String
    career_length: String
    circumcised: String
    country: String
    death_date: String
    details: String
    disambiguation: String
    ethnicity: String
    eye_color: String
    fake_tits: String
    gender: String
    hair_color: String
    height: String
    instagram: String
    measurements: String
    name: String
    penis_length: String
    piercings: String
    remote_site_id: String
    "Set if performer matched"
    stored_id: ID
    tattoos: String
    twitter: String
    url: String
    weight: String
}

input ScrapedSceneInput {
    code: String
    date: String
    details: String
    director: String
    remote_site_id: String
    title: String
    url: String
    urls: [String!]
}

input ScraperSourceInput {
    "Scraper ID to scrape with. Should be unset if stash_box_index is set"
    scraper_id: ID
    "Stash-box endpoint"
    stash_box_endpoint: String
    "Index of the configured stash-box instance to use. Should be unset if scraper_id is set"
    stash_box_index: Int
}

input SetDefaultFilterInput {
    "null to clear"
    find_filter: FindFilterType
    mode: FilterMode!
    object_filter: Map
    ui_options: Map
}

input SetupInput {
    "Empty to indicate default - only applicable if storeBlobsInDatabase is false"
    blobsLocation: String!
    "Empty to indicate default"
    cacheLocation: String!
    "Empty to indicate $HOME/.stash/config.yml default"
    configLocation: String!
    "Empty to indicate default"
    databaseFile: String!
    "Empty to indicate default"
    generatedLocation: String!
    stashes: [StashConfigInput!]!
    storeBlobsInDatabase: Boolean!
}

"If neither ids nor names are set, tag all items"
input StashBoxBatchTagInput {
    "If batch adding studios, should their parent studios also be created?"
    createParent: Boolean!
    "Stash endpoint to use for the tagging"
    endpoint: Int!
    "Fields to exclude when executing the tagging"
    exclude_fields: [String!]
    "If set, only tag these ids"
    ids: [ID!]
    "If set, only tag these names"
    names: [String!]
    "If set, only tag these performer ids"
    performer_ids: [ID!]
    "If set, only tag these performer names"
    performer_names: [String!]
    "Refresh items already tagged by StashBox if true. Only tag items with no StashBox tagging if false"
    refresh: Boolean!
}

input StashBoxDraftSubmissionInput {
    id: String!
    stash_box_index: Int!
}

input StashBoxFingerprintSubmissionInput {
    scene_ids: [String!]!
    stash_box_index: Int!
}

input StashBoxInput {
    api_key: String!
    endpoint: String!
    name: String!
}

input StashBoxPerformerQueryInput {
    "Instructs query by scene fingerprints"
    performer_ids: [ID!]
    "Query by query string"
    q: String
    "Index of the configured stash-box instance to use"
    stash_box_index: Int!
}

input StashBoxSceneQueryInput {
    "Query by query string"
    q: String
    "Instructs query by scene fingerprints"
    scene_ids: [ID!]
    "Index of the configured stash-box instance to use"
    stash_box_index: Int!
}

"Stash configuration details"
input StashConfigInput {
    excludeImage: Boolean!
    excludeVideo: Boolean!
    path: String!
}

input StashIDCriterionInput {
    """

    If present, this value is treated as a predicate.
    That is, it will filter based on stash_ids with the matching endpoint
    """
    endpoint: String
    modifier: CriterionModifier!
    stash_id: String
}

input StashIDInput {
    endpoint: String!
    stash_id: String!
}

input StringCriterionInput {
    modifier: CriterionModifier!
    value: String!
}

input StudioCreateInput {
    aliases: [String!]
    details: String
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    name: String!
    parent_id: ID
    rating: Int
    rating100: Int
    stash_ids: [StashIDInput!]
    url: String
}

input StudioDestroyInput {
    id: ID!
}

input StudioFilterType {
    AND: StudioFilterType
    NOT: StudioFilterType
    OR: StudioFilterType
    "Filter by studio aliases"
    aliases: StringCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    details: StringCriterionInput
    "Filter by gallery count"
    gallery_count: IntCriterionInput
    "Filter by autotag ignore value"
    ignore_auto_tag: Boolean
    "Filter by image count"
    image_count: IntCriterionInput
    "Filter to only include studios missing this property"
    is_missing: String
    name: StringCriterionInput
    "Filter to only include studios with this parent studio"
    parents: MultiCriterionInput
    "Filter by rating"
    rating: IntCriterionInput
    rating100: IntCriterionInput
    "Filter by scene count"
    scene_count: IntCriterionInput
    "Filter by StashID"
    stash_id: StringCriterionInput
    "Filter by StashID"
    stash_id_endpoint: StashIDCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
    "Filter by url"
    url: StringCriterionInput
}

input StudioUpdateInput {
    aliases: [String!]
    details: String
    id: ID!
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    name: String
    parent_id: ID
    rating: Int
    rating100: Int
    stash_ids: [StashIDInput!]
    url: String
}

input TagCreateInput {
    aliases: [String!]
    child_ids: [ID!]
    description: String
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    name: String!
    parent_ids: [ID!]
}

input TagDestroyInput {
    id: ID!
}

input TagFilterType {
    AND: TagFilterType
    NOT: TagFilterType
    OR: TagFilterType
    "Filter by tag aliases"
    aliases: StringCriterionInput
    "Filter by number f child tags the tag has"
    child_count: IntCriterionInput
    "Filter by child tags"
    children: HierarchicalMultiCriterionInput
    "Filter by creation time"
    created_at: TimestampCriterionInput
    "Filter by tag description"
    description: StringCriterionInput
    "Filter by number of galleries with this tag"
    gallery_count: IntCriterionInput
    "Filter by autotag ignore value"
    ignore_auto_tag: Boolean
    "Filter by number of images with this tag"
    image_count: IntCriterionInput
    "Filter to only include tags missing this property"
    is_missing: String
    "Filter by number of markers with this tag"
    marker_count: IntCriterionInput
    "Filter by tag name"
    name: StringCriterionInput
    "Filter by number of parent tags the tag has"
    parent_count: IntCriterionInput
    "Filter by parent tags"
    parents: HierarchicalMultiCriterionInput
    "Filter by number of performers with this tag"
    performer_count: IntCriterionInput
    "Filter by number of scenes with this tag"
    scene_count: IntCriterionInput
    "Filter by last update time"
    updated_at: TimestampCriterionInput
}

input TagUpdateInput {
    aliases: [String!]
    child_ids: [ID!]
    description: String
    id: ID!
    ignore_auto_tag: Boolean
    "This should be a URL or a base64 encoded data URL"
    image: String
    name: String
    parent_ids: [ID!]
}

input TagsMergeInput {
    destination: ID!
    source: [ID!]!
}

input TimestampCriterionInput {
    modifier: CriterionModifier!
    value: String!
    value2: String
}
